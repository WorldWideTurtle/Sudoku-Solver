{"version":3,"file":"static/js/850.3fd12d97.chunk.js","mappings":"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","sources":["lib/util/sudokuUtil.ts","lib/sudoku/nSet.ts","lib/sudoku/nGrid.ts","lib/sudoku/worker.ts"],"sourcesContent":["export const sudokuUtil = {\r\n    decode(str : string) : number[][] {\r\n        let newArr = new Array(9);\r\n        for (let i = 0; i < 81; i+=9) {\r\n            let row = new Array(9);\r\n            for (let j = 0; j < 9; j++) {\r\n                row[j] = (+str[i + j]);\r\n            }\r\n            newArr[i/9] = row;\r\n        }\r\n        return newArr;\r\n    },\r\n\r\n    encode(arr : number[][]) {\r\n        return arr.reduce((row,nextRow)=>row.concat(nextRow.reduce<string>((p,c)=>p+=c.toString(),\"\"),\"\"),\"\");\r\n    },\r\n\r\n    isValid(str: string) {\r\n        const arr = this.decode(str);\r\n\r\n        for (let r = 0; r < 9; r++) {\r\n            let rowSet = new Set<number>()\r\n            let colSet = new Set<number>()\r\n            let squareSet = new Set<number>()\r\n\r\n            let row = arr[r];\r\n            for (let c = 0; c < 9; c++) {\r\n                const rowNumber = row[c]\r\n                const colNumber = arr[c][r]\r\n\r\n                const squareRow = (~~(r / 3)) * 3 + (~~(c / 3));\r\n                const squareNumber = arr[squareRow][c % 3];\r\n\r\n                if (rowNumber !== 0) {\r\n                    if (rowSet.has(rowNumber)) {\r\n                        return false;\r\n                    } else {\r\n                        rowSet.add(rowNumber)\r\n                    }\r\n                };\r\n\r\n                if (colNumber !== 0) {\r\n                    if (colSet.has(colNumber)) {\r\n                        return false;\r\n                    } else {\r\n                        colSet.add(colNumber)\r\n                    }\r\n                }\r\n\r\n                if (squareNumber !== 0) {\r\n                    if (squareSet.has(squareNumber)) {\r\n                        return false;\r\n                    } else {\r\n                        squareSet.add(squareNumber)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}","export type NSet = number;\r\n\r\nexport const nSet = {\r\n    /**\r\n     * Creates a new nSet from an array\r\n     */\r\n    new: function(args : number[]) : NSet {\r\n        let newSet = 0;\r\n        for (let i = 0; i < args.length; i++) {\r\n            //Intermediate shift to the left to avoid if 0 check.\r\n            newSet = ((newSet<<1) | (1 << args[i]))>>>1;\r\n        }\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * Returns the elements in either nSet\r\n     */\r\n    union: (a : NSet,b : NSet) : NSet => a|b,\r\n\r\n    /**\r\n     * Returns the log base 2 of a 32 bit power of 2.\r\n     */\r\n    log2: (x : number) : number => (31 - Math.clz32(x)) | 0,\r\n\r\n    /**\r\n     * Returns the elements common in both nSets\r\n     */\r\n    intersect: (a : NSet,b : NSet) : NSet => a|b,\r\n\r\n    /**\r\n     * Returns the elements not common in both nSets\r\n     */\r\n    difference: (a : NSet,b : NSet) : NSet => a^b,\r\n\r\n    /**\r\n     * Subtracts one nSet from another\r\n     */\r\n    subtract: (a : NSet,b : NSet) : NSet => a&~b,\r\n\r\n    /**\r\n     * Checks if the set contains a certain element\r\n     */\r\n    has: function(a : NSet,b : number) : NSet {\r\n        return a & (1<<(b-1));\r\n    },\r\n\r\n    /**\r\n     * Checks if the set contains only a single element\r\n     */\r\n    isSingle: function(a : NSet) : boolean {\r\n        return (a && !(a & (a - 1))) as boolean;\r\n    },\r\n\r\n    /**\r\n     * Returnes the first element of the Set\r\n     */\r\n    first: function(a : NSet) : number  {\r\n        return this.log2(a & (-a)) + 1;\r\n    },\r\n\r\n    /**\r\n     * Returnes the first element of the Set\r\n     */\r\n    firstBit: function(a : NSet) : NSet {\r\n        return a & (-a);\r\n    },\r\n\r\n    /**\r\n     * Deletes the first element of the Set\r\n     */\r\n    shift: function(a : NSet) : NSet {\r\n        return a & (a-1);\r\n    },\r\n\r\n    /**\r\n     * Deletes the target value from the set\r\n     */\r\n    delete: function(a : NSet,b = 0) : NSet {\r\n        //Intermediate shift to the left to avoid if 0 check.\r\n        return ((a<<1) & ~(1<<b))>>>1;\r\n    },\r\n\r\n    /**\r\n     * Deletes the target bit from the set\r\n     */\r\n    removeBit(a : NSet,b : NSet) : NSet {\r\n        return a & (~b)\r\n    },\r\n\r\n    /**\r\n     * Adds the target value to the set\r\n     */\r\n    add: function(a : NSet,b : number) : NSet {\r\n        //Intermediate shift to the left to avoid if 0 check.\r\n        return ((a<<1)|(1<<(b)))>>>1;\r\n    },\r\n\r\n    /**\r\n     * Converts the nSet to binaray representation\r\n     */\r\n    toString: function(a : NSet) {\r\n        return a.toString(2);\r\n    },\r\n\r\n    /**\r\n     * Counts the elements in the nSet\r\n     */\r\n    size: function(a : NSet) {\r\n        a = a-((a >>> 1) & 0x55555555)\r\n        a = (a & 0x33333333) + ((a >>> 2) & 0x33333333)\r\n        return ((a + (a >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\r\n    },\r\n\r\n    /**\r\n     * Converts the nSet to array representation\r\n     */\r\n    toArray: function(a : NSet) {\r\n        let arr = new Uint8Array(9);\r\n        let i = 0;\r\n        while (a>0) {\r\n            arr[i++] = (a & 1) * i;\r\n            a >>>= 1;\r\n        }\r\n        return arr;\r\n    },\r\n}","import { NSet, nSet } from \"./nSet\";\r\n\r\nconst baseLowest = ((0x1FF<<9)|(10<<4)|10);\r\n\r\n// (i%9)*9 + ~~(i/9)\r\nconst columnLookup = [\r\n    0,  9, 18, 27, 36, 45, 54, 63, 72, \r\n    1, 10, 19, 28, 37, 46, 55, 64, 73, \r\n    2, 11, 20, 29, 38, 47, 56, 65, 74, \r\n    3, 12, 21, 30, 39, 48, 57, 66, 75, \r\n    4, 13, 22, 31, 40, 49, 58, 67, 76, \r\n    5, 14, 23, 32, 41, 50, 59, 68, 77, \r\n    6, 15, 24, 33, 42, 51, 60, 69, 78, \r\n    7, 16, 25, 34, 43, 52, 61, 70, 79, \r\n    8, 17, 26, 35, 44, 53, 62, 71, 80\r\n];\r\n\r\n// ~~(i/27)*27 + ~~(i/9)%3*3 + i%3 + ~~((i%9)/3)*9\r\nconst squareLookup = [\r\n     0,  1,  2,  9, 10, 11, 18, 19, 20, \r\n     3,  4,  5, 12, 13, 14, 21, 22, 23, \r\n     6,  7,  8, 15, 16, 17, 24, 25, 26, \r\n    27, 28, 29, 36, 37, 38, 45, 46, 47, \r\n    30, 31, 32, 39, 40, 41, 48, 49, 50, \r\n    33, 34, 35, 42, 43, 44, 51, 52, 53, \r\n    54, 55, 56, 63, 64, 65, 72, 73, 74, \r\n    57, 58, 59, 66, 67, 68, 75, 76, 77, \r\n    60, 61, 62, 69, 70, 71, 78, 79, 80\r\n];\r\n\r\nexport class nGrid {\r\n    initialState? : number[][] = [];\r\n\r\n    rowState = new Uint8Array(81);\r\n\r\n    activeRowSet = new Uint16Array(9);\r\n    activeColumnSet = new Uint16Array(9);\r\n    activeSquareSet = new Uint16Array(9);\r\n\r\n    steps : number[][] = [[]];\r\n    activeStep = 1;\r\n\r\n    reverseCount = 0;\r\n    itterationCount = 0;\r\n    singleCount = 0;\r\n    hiddenCount = 0;\r\n    guesses = 0;\r\n    solveTime = 0;\r\n\r\n    constructor(initial? : number[][]) {\r\n        this.initialState = initial;\r\n        if (initial) {this.init()};\r\n    }\r\n\r\n    load(grid : number[][]) {\r\n        this.initialState = grid;\r\n    }\r\n    \r\n    reset() {\r\n        this.reverseCount = 0;\r\n        this.itterationCount = 0;\r\n        this.steps = [[]];\r\n        this.activeStep = 1;\r\n        this.singleCount = 0;\r\n        this.hiddenCount = 0;\r\n        this.guesses = 0;\r\n    }\r\n\r\n    splitArray(arr: Uint8Array,size: number) : Uint8Array[] {\r\n        let res = new Array(arr.length/size);\r\n        for (let i = 0; i < arr.length; i+=size) {\r\n            let newArr = new Uint8Array(size);\r\n            for (let j = 0; j < size; j++) {\r\n                newArr[j] = arr[i+j];\r\n            }\r\n            res[i/size] = newArr;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    init() {\r\n        if (this.initialState === undefined) return;\r\n        this.reset()\r\n\r\n        let tmpRowState = new Uint8Array(this.initialState.flat())\r\n        this.rowState = tmpRowState;\r\n\r\n        for (let i = 0; i < 9; i++) {\r\n            let i9 = i * 9;\r\n            let sets = 0;\r\n            for (let j = 0; j < 9; j++) {\r\n                sets |= (1 << (tmpRowState[i9 + j] - 1)) | ((1 << (tmpRowState[columnLookup[i9 + j]] - 1)) << 9) | ((1 << (tmpRowState[squareLookup[i9 + j]] - 1)) << 18)\r\n            }\r\n            this.activeRowSet[i] = sets & 0x1FF;\r\n            this.activeColumnSet[i] = (sets >>> 9) & 0x1FF;\r\n            this.activeSquareSet[i] = (sets >>> 18) & 0x1FF;\r\n        }\r\n    }\r\n\r\n    getRowArray = () => this.splitArray(this.rowState,9);\r\n\r\n    getRowSet = () => Array.from(this.activeRowSet).map(e=>nSet.toArray(e));\r\n\r\n    getColumnSet = () => Array.from(this.activeColumnSet).map(e=>nSet.toArray(e));\r\n\r\n    getSquareSet = () => Array.from(this.activeSquareSet).map(e=>nSet.toArray(e));\r\n\r\n    getEntropy(row: number,column : number) {\r\n        if (this.getValueAt(row,column) !== 0) return 0;\r\n        return (this.activeRowSet[row]|this.activeColumnSet[column]|this.activeSquareSet[~~(column/3) + ~~(row/3)*3])^(0x1FF);\r\n    }\r\n\r\n    getEntropyAbs(row : number,column : number) {\r\n        return (this.activeRowSet[row]|this.activeColumnSet[column]|this.activeSquareSet[~~(column/3) + ~~(row/3)*3])^(0x1FF);\r\n    }\r\n\r\n    getValueAt = (row : number,column : number) => this.rowState[row * 9 + column];\r\n\r\n    getValueAtIndex = (index : number) => this.rowState[index];\r\n\r\n    checkSolvedCondition(set: Uint16Array) {\r\n        return (Array.from(set).reduce((acc,cur)=>acc & cur, 0x1FF) === 0x1FF)\r\n    }\r\n\r\n    isSolved() {\r\n        return (\r\n            this.checkSolvedCondition(this.activeRowSet) \r\n            && this.checkSolvedCondition(this.activeColumnSet) \r\n            && this.checkSolvedCondition(this.activeSquareSet)\r\n        );\r\n    }\r\n\r\n    totalEntropy() {\r\n        let arr: Uint8Array[]  = []\r\n        for (let row = 0; row < 9; row++) {\r\n            let rowArray = new Uint8Array(9);\r\n            for (let column = 0; column < 9; column++) {\r\n                rowArray[column] = nSet.size(this.getEntropy(row,column));\r\n            }\r\n            arr.push(rowArray);\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    solve(full : boolean) {\r\n        // Main loop\r\n        // Itterate over methods from most to least effective.\r\n        let itter = 0;\r\n        this.solveTime = performance.now();\r\n        this.solveHidden()\r\n        do {\r\n            itter++;\r\n            if(this.solveObviousSingles() || this.solveHidden() || this.guess()) {continue};\r\n            break;\r\n        } while (full)\r\n        this.solveTime = performance.now() - this.solveTime;\r\n        this.itterationCount += itter;\r\n    }\r\n\r\n    solveObviousSingles() {\r\n        let found = false;\r\n        for (let row = 0; row < 9; row++) {\r\n            if (this.activeRowSet[row] === 0x1FF) continue;\r\n            for (let column = 0; column < 9; column++) {\r\n                // GetValueAtIndex;\r\n                if (this.rowState[Math.imul(row,9) + column] !== 0) continue;\r\n\r\n                // GetEntropyAps\r\n                const entp = (this.activeRowSet[row]|this.activeColumnSet[column]|this.activeSquareSet[~~(column/3) + ~~Math.imul(row/3,3)])^(0x1FF);\r\n                // IsSingle\r\n                if (entp === 0) {\r\n                    return this.backTrack();\r\n                } else if ((entp & (entp - 1)) === 0) {\r\n                    this.set(row,column,nSet.log2(entp)+1);\r\n                    this.singleCount++;\r\n                    found = true;\r\n                }\r\n            }\r\n        }\r\n        return found;\r\n    }\r\n\r\n    solveHidden() {\r\n        // Solve hidden singles in Rows and Columns\r\n        // A hidden single is a cell in which one of the possible numbers is unique to this cell, along a capture group.\r\n        // Check each cell and add the options to a set. If the number is already in the set, move it to another set. \r\n        // Any numbers remaining in the initial set have only been encountered once.\r\n        for (let row = 0; row < 9; row++) {\r\n            if (this.activeRowSet[row] === 0x1FF) continue;\r\n            let previousRow = 0;\r\n            let potentialRow = 0;\r\n            \r\n            for (let col = 8; col !== -1; col--) {\r\n                if (previousRow === 0x1FF) break;\r\n                // GetValueAt\r\n                if (this.rowState[row * 9 + col] !== 0) continue; \r\n\r\n                let entropy = this.getEntropyAbs(row,col);\r\n                previousRow |= (potentialRow & entropy);\r\n                potentialRow = (potentialRow | entropy) & (~previousRow)\r\n                \r\n            }\r\n\r\n            if (potentialRow && !(potentialRow & (potentialRow - 1))) {\r\n                for (let col = 8; col !== -1; col--) {\r\n                    // GetValueAt\r\n                    if (this.rowState[row * 9 + col] !== 0) continue; \r\n                    if ((this.getEntropyAbs(row,col) & potentialRow) === 0) continue;\r\n\r\n                    this.set(row,col,nSet.log2(potentialRow)+1);\r\n                    this.hiddenCount++;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let row = 8; row !== -1; row--) {\r\n            if (this.activeColumnSet[row] === 0x1FF) continue;\r\n            let previousCol = 0;\r\n            let potentialCol = 0;\r\n            for (let col = 0; col < 9; col++) {\r\n                if (previousCol === 0x1FF) break;\r\n                // GetValueAt\r\n                if (this.rowState[col * 9 + row] !== 0) continue; \r\n\r\n                let entropy = this.getEntropyAbs(col,row);\r\n                previousCol |= (potentialCol & entropy);\r\n                potentialCol = (potentialCol | entropy) & (~previousCol)\r\n            }\r\n            \r\n            if (potentialCol && !(potentialCol & (potentialCol - 1))) {\r\n                for (let col = 0; col < 9; col++) {\r\n                    // GetValueAt\r\n                    if (this.rowState[col * 9 + row] !== 0) continue;\r\n                    if ((this.getEntropyAbs(col,row) & potentialCol) === 0) continue;\r\n\r\n                    this.set(col,row,nSet.log2(potentialCol)+1);\r\n                    this.hiddenCount++;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    guessCell(row : number,column : number,ent : NSet) {\r\n        this.guesses++;\r\n        let first = nSet.first(ent)\r\n        this.set(row,column,first);\r\n        this.activeStep = this.steps.push([(first<<18)|((ent & (ent - 1))<<9)|(row<<4)|column])\r\n    }\r\n\r\n    guess() {\r\n        let lowest = baseLowest;\r\n        let ent = 0;\r\n        for (let row = 8;row >= 0; row--) {\r\n            if (this.activeRowSet[row] === 0x1FF) continue;\r\n            for (let column = 8; column >= 0; column--) {\r\n                // GetValueAt\r\n                if (this.rowState[row * 9 + column] !== 0) continue;\r\n\r\n                ent = this.getEntropyAbs(row,column);\r\n                if (nSet.size(ent) >= nSet.size(lowest>>>9)) continue;\r\n\r\n                lowest = (ent<<9)|(row<<4)|column;\r\n                if (nSet.size(ent) === 2) {\r\n                    this.guessCell(row,column,ent);\r\n                    return true;\r\n                }\r\n                \r\n            }\r\n        }\r\n        \r\n        if (lowest === baseLowest) return false;\r\n\r\n        this.guessCell((lowest>>>4)&0xF,lowest&0xF,lowest>>>9)\r\n        return true;\r\n    }\r\n\r\n    backTrack() {\r\n        while (this.activeStep > 1) {\r\n            const lastStep = this.steps[this.activeStep-1];\r\n            let guessStep = lastStep[0];\r\n            if (nSet.size((guessStep>>>9)&0x1FF) !== 0) {\r\n                this.reverseCount+=lastStep.length;\r\n                for (const step of lastStep) {\r\n                    this.reverse(step);\r\n                }\r\n                let val = nSet.first((guessStep>>>9)&0x1FF)\r\n                this.set((guessStep>>>4)&0xF,guessStep&0xF, val);\r\n                this.steps[this.activeStep-1] = [(val<<18)|(nSet.shift((guessStep>>>9)&0x1FF)<<9)|(guessStep&0xF0)|(guessStep&0xF)];\r\n                break;\r\n            } else {\r\n                if (this.activeStep <= 2) return false;\r\n\r\n                this.reverseCount+=lastStep.length;\r\n                for (const step of this.steps.pop()!) { // Can't be undefined if activeStep > 0\r\n                    this.reverse(step);\r\n                }\r\n\r\n                this.activeStep--;\r\n            }\r\n        }\r\n\r\n        return false\r\n    }\r\n    \r\n    undo() {\r\n        if (this.activeStep === 0) return;\r\n        const lastStep = this.steps[this.activeStep-1];\r\n        this.reverse(lastStep.pop()!) // Can't be undefined if activeStep > 0\r\n    }\r\n\r\n    set(row : number,column : number,value : number) {\r\n        this.steps[this.activeStep-1].push((value<<18)|(row<<4)|(column));\r\n        // nSet.add\r\n        this.activeRowSet[row] = this.activeRowSet[row] | (1 << (value - 1));\r\n        this.activeColumnSet[column] = this.activeColumnSet[column] | (1 << (value - 1));\r\n        this.activeSquareSet[~~(column/3) + ~~(row/3)*3] = this.activeSquareSet[~~(column/3) + ~~(row/3)*3] | (1 << (value - 1));\r\n\r\n        this.rowState[row * 9 + column] = value;\r\n    }\r\n\r\n    reverse(step : number) {\r\n        const row = (step>>>4)&0xF;\r\n        const column = step&0xF;\r\n        const value = step>>>18;\r\n\r\n        // nSet.remove\r\n        this.activeRowSet[row] = this.activeRowSet[row] &  ~(1 << (value - 1));\r\n        this.activeColumnSet[column] = this.activeColumnSet[column] & ~(1 << (value - 1));\r\n        this.activeSquareSet[~~(column/3) + ~~(row/3)*3] = this.activeSquareSet[~~(column/3) + ~~(row/3)*3] & ~(1 << (value - 1));\r\n\r\n        this.rowState[row * 9 + column] = 0;\r\n    }\r\n}","import { sudokuUtil } from \"../util/sudokuUtil\";\r\nimport { nGrid } from \"./nGrid\";\r\n\r\nconst grid = new nGrid();\r\n\r\nexport type GridEventData = {\r\n    data: {\r\n        partial? : boolean,\r\n        grids: string[]\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line no-restricted-globals\r\nself.onmessage = (event : GridEventData) =>{    \r\n    if (event.data.partial === true) {\r\n        event.data.grids.forEach(element => {\r\n            grid.load(sudokuUtil.decode(element));\r\n            grid.init();\r\n            grid.solve(true);\r\n            postMessage(grid.solveTime);\r\n        });\r\n    } else {\r\n        let total = 0;\r\n        let grids = event.data.grids;\r\n        let length = grids.length;\r\n        for (let i = 0; i < length; i++) {\r\n            grid.load(sudokuUtil.decode(grids[i]));\r\n            grid.init();\r\n            grid.solve(true);\r\n            total += grid.solveTime;\r\n        }\r\n        postMessage(total)\r\n    }\r\n}\r\n"],"names":["sudokuUtil","decode","str","newArr","Array","i","row","j","encode","arr","reduce","nextRow","concat","p","c","toString","isValid","this","r","rowSet","Set","colSet","squareSet","rowNumber","colNumber","squareNumber","has","add","nSet","new","args","newSet","length","union","a","b","log2","x","Math","clz32","intersect","difference","subtract","isSingle","first","firstBit","shift","delete","arguments","undefined","removeBit","size","toArray","Uint8Array","baseLowest","columnLookup","squareLookup","grid","constructor","initial","initialState","rowState","activeRowSet","Uint16Array","activeColumnSet","activeSquareSet","steps","activeStep","reverseCount","itterationCount","singleCount","hiddenCount","guesses","solveTime","getRowArray","splitArray","getRowSet","from","map","e","getColumnSet","getSquareSet","getValueAt","column","getValueAtIndex","index","init","load","reset","res","tmpRowState","flat","i9","sets","getEntropy","getEntropyAbs","checkSolvedCondition","set","acc","cur","isSolved","totalEntropy","rowArray","push","solve","full","itter","performance","now","solveHidden","solveObviousSingles","guess","found","imul","entp","backTrack","previousRow","potentialRow","col","entropy","previousCol","potentialCol","guessCell","ent","lowest","lastStep","guessStep","step","reverse","val","pop","undo","value","self","onmessage","event","data","partial","grids","forEach","element","postMessage","total"],"sourceRoot":""}